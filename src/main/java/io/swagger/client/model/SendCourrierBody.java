/*
 * Merci facteur API
 * Merci facteur PRO vous permet d'envoyer des courriers depuis votre applicatif via son API.     Types de courriers disponibles :   - Lettre de une ou plusieurs pages.  - Carte postale avec ou sans enveloppe  - Carte pliée  - Carte géante  - Carte non pliée  - Photos sur papier brillant    Modes d'envois disponibles :   - Envoi normal (lettre verte)  - Lettre suivie  - Recommandé avec avis de réception      Au sujet des webhooks : [`https://github.com/MerciFacteur/Merci-facteur-API/blob/master/README.md#webhooks`](https://github.com/MerciFacteur/Merci-facteur-API/blob/master/README.md#webhooks)     Librairie PHP et exemples d'intégration : [`https://github.com/MerciFacteur/Merci-facteur-API`](https://github.com/MerciFacteur/Merci-facteur-API)    Infos générales sur l'API : [`https://github.com/MerciFacteur/Merci-facteur-API/blob/master/README.md`](https://github.com/MerciFacteur/Merci-facteur-API/blob/master/README.md)    Plus d'informations sur [`https://www.merci-facteur.com/pro`](https://www.merci-facteur.com/pro)    N'hésitez pas à nous contacter via [`https://www.merci-facteur.com/pro/contact.php`](https://www.merci-facteur.com/pro/contact.php)
 *
 * OpenAPI spec version: 1.2.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.AdressSendCourrier;
import io.swagger.client.model.SendCourrierAnonymize;
import io.swagger.client.model.SendCourrierContent;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * SendCourrierBody
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2023-11-30T14:41:58.166575150Z[GMT]")

public class SendCourrierBody {
  @SerializedName("idUser")
  private Integer idUser = null;

  /**
   * Mode d&#x27;envoi du courrier : suivi, lrar, lrare, ou normal pour les envois papier. ere_otp_mail ou ere_otp_sms pour les recommandés électroniques.
   */
  @JsonAdapter(ModeEnvoiEnum.Adapter.class)
  public enum ModeEnvoiEnum {
    @SerializedName("normal")
    NORMAL("normal"),
    @SerializedName("suivi")
    SUIVI("suivi"),
    @SerializedName("lrar")
    LRAR("lrar"),
    @SerializedName("lrare")
    LRARE("lrare"),
    @SerializedName("ere_otp_mail")
    ERE_OTP_MAIL("ere_otp_mail"),
    @SerializedName("ere_otp_sms")
    ERE_OTP_SMS("ere_otp_sms");

    private String value;

    ModeEnvoiEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ModeEnvoiEnum fromValue(String input) {
      for (ModeEnvoiEnum b : ModeEnvoiEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ModeEnvoiEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModeEnvoiEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public ModeEnvoiEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ModeEnvoiEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("modeEnvoi")
  private ModeEnvoiEnum modeEnvoi = null;

  @SerializedName("adress")
  private AdressSendCourrier adress = null;

  @SerializedName("dateEnvoi")
  private String dateEnvoi = null;

  @SerializedName("designation")
  private String designation = null;

  @SerializedName("anonymize")
  private SendCourrierAnonymize anonymize = null;

  @SerializedName("content")
  private SendCourrierContent content = null;

  public SendCourrierBody idUser(Integer idUser) {
    this.idUser = idUser;
    return this;
  }

   /**
   * user ID de l&#x27;utilisateur qui envoi le courrier
   * @return idUser
  **/
  @Schema(description = "user ID de l'utilisateur qui envoi le courrier")
  public Integer getIdUser() {
    return idUser;
  }

  public void setIdUser(Integer idUser) {
    this.idUser = idUser;
  }

  public SendCourrierBody modeEnvoi(ModeEnvoiEnum modeEnvoi) {
    this.modeEnvoi = modeEnvoi;
    return this;
  }

   /**
   * Mode d&#x27;envoi du courrier : suivi, lrar, lrare, ou normal pour les envois papier. ere_otp_mail ou ere_otp_sms pour les recommandés électroniques.
   * @return modeEnvoi
  **/
  @Schema(description = "Mode d'envoi du courrier : suivi, lrar, lrare, ou normal pour les envois papier. ere_otp_mail ou ere_otp_sms pour les recommandés électroniques.")
  public ModeEnvoiEnum getModeEnvoi() {
    return modeEnvoi;
  }

  public void setModeEnvoi(ModeEnvoiEnum modeEnvoi) {
    this.modeEnvoi = modeEnvoi;
  }

  public SendCourrierBody adress(AdressSendCourrier adress) {
    this.adress = adress;
    return this;
  }

   /**
   * Get adress
   * @return adress
  **/
  @Schema(description = "")
  public AdressSendCourrier getAdress() {
    return adress;
  }

  public void setAdress(AdressSendCourrier adress) {
    this.adress = adress;
  }

  public SendCourrierBody dateEnvoi(String dateEnvoi) {
    this.dateEnvoi = dateEnvoi;
    return this;
  }

   /**
   * Date d&#x27;envoi souhaitée du courrier. Si vide ou non spécifié, l&#x27;envoi sera fait le jour même (ou le jour ouvrable suivant). Doit être au format AAAA-MM-JJ et doit être une date non passée.
   * @return dateEnvoi
  **/
  @Schema(description = "Date d'envoi souhaitée du courrier. Si vide ou non spécifié, l'envoi sera fait le jour même (ou le jour ouvrable suivant). Doit être au format AAAA-MM-JJ et doit être une date non passée.")
  public String getDateEnvoi() {
    return dateEnvoi;
  }

  public void setDateEnvoi(String dateEnvoi) {
    this.dateEnvoi = dateEnvoi;
  }

  public SendCourrierBody designation(String designation) {
    this.designation = designation;
    return this;
  }

   /**
   * Facultatif, 50 caractères maximum, la designation sera reprise sur votre interface Merci facteur pro dans le listing de vos courriers afin de faciliter vos recherches. Pour les envois recommandés élécroniques (ERE) la designation sera présente dans l&#x27;email envoyé à votre destinataire
   * @return designation
  **/
  @Schema(description = "Facultatif, 50 caractères maximum, la designation sera reprise sur votre interface Merci facteur pro dans le listing de vos courriers afin de faciliter vos recherches. Pour les envois recommandés élécroniques (ERE) la designation sera présente dans l'email envoyé à votre destinataire")
  public String getDesignation() {
    return designation;
  }

  public void setDesignation(String designation) {
    this.designation = designation;
  }

  public SendCourrierBody anonymize(SendCourrierAnonymize anonymize) {
    this.anonymize = anonymize;
    return this;
  }

   /**
   * Get anonymize
   * @return anonymize
  **/
  @Schema(description = "")
  public SendCourrierAnonymize getAnonymize() {
    return anonymize;
  }

  public void setAnonymize(SendCourrierAnonymize anonymize) {
    this.anonymize = anonymize;
  }

  public SendCourrierBody content(SendCourrierContent content) {
    this.content = content;
    return this;
  }

   /**
   * Get content
   * @return content
  **/
  @Schema(description = "")
  public SendCourrierContent getContent() {
    return content;
  }

  public void setContent(SendCourrierContent content) {
    this.content = content;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SendCourrierBody sendCourrierBody = (SendCourrierBody) o;
    return Objects.equals(this.idUser, sendCourrierBody.idUser) &&
        Objects.equals(this.modeEnvoi, sendCourrierBody.modeEnvoi) &&
        Objects.equals(this.adress, sendCourrierBody.adress) &&
        Objects.equals(this.dateEnvoi, sendCourrierBody.dateEnvoi) &&
        Objects.equals(this.designation, sendCourrierBody.designation) &&
        Objects.equals(this.anonymize, sendCourrierBody.anonymize) &&
        Objects.equals(this.content, sendCourrierBody.content);
  }

  @Override
  public int hashCode() {
    return Objects.hash(idUser, modeEnvoi, adress, dateEnvoi, designation, anonymize, content);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SendCourrierBody {\n");
    
    sb.append("    idUser: ").append(toIndentedString(idUser)).append("\n");
    sb.append("    modeEnvoi: ").append(toIndentedString(modeEnvoi)).append("\n");
    sb.append("    adress: ").append(toIndentedString(adress)).append("\n");
    sb.append("    dateEnvoi: ").append(toIndentedString(dateEnvoi)).append("\n");
    sb.append("    designation: ").append(toIndentedString(designation)).append("\n");
    sb.append("    anonymize: ").append(toIndentedString(anonymize)).append("\n");
    sb.append("    content: ").append(toIndentedString(content)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
